Html


<!DOCTYPE html>
<!-- Leaflet + D3 demo for Victoria LGAs (prettified, same logic) -->
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;700&display=swap" rel="stylesheet">

<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Victoria LGAs Map</title>

  <!-- libs -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  

  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">

</head>
<body>

<!-- map + side panel -->
<div id="map"></div>

<div id="chart-panel">
  <h4 id="chart-title">LGA Info</h4>
  <button id="close-btn">Close</button>
  <div id="popup-plot"></div>
  <div id="tooltip" class="tooltip"></div>
</div>

<script>
/* Leaflet map */
const map = L.map('map').setView([-37.5, 144.5], 7);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '© OpenStreetMap contributors'
}).addTo(map);

/* cached DOM refs */
const panel   = document.getElementById('chart-panel');
const titleEl = document.getElementById('chart-title');
const plotEl  = document.getElementById('popup-plot');
const tooltip = d3.select('#tooltip');

document.getElementById('close-btn').onclick = () => (panel.style.display = 'none');

function showPanel(title) {
  titleEl.textContent = title;
  panel.style.display = 'block';
  plotEl.innerHTML = '';
  tooltip.style('opacity', 0);
}

/**
 * Append a data‐source link under the chart
 */
 function addSource(text, url) {
  const a = document.createElement('a');
  a.href       = url;
  a.target     = '_blank';
  a.rel        = 'noopener';
  a.textContent= text;
  a.className  = 'data-source';
  plotEl.appendChild(a);
}

// Load GeoJSON data for Victoria LGAs
fetch('vic_lga_cleaned.geojson')
  .then(r => r.json())
  .then(geo => {
    // Add the LGA GeoJSON layer to the Leaflet map
    L.geoJSON(geo, {
      style: {
        color: '#444',
        weight: 1,
        fillColor: '#99ccff',
        fillOpacity: 0.6
      },
      // Bind popup and interactive behavior to each feature (LGA) and get lga name and code
      onEachFeature: (feature, layer) => {
        // Get the lga name and lga code , bind them with the popup content. Include the council info and stats buttos for each LGA. 
        const name = feature.properties.lga_name;
        const code = feature.properties.lga_code;

        layer.bindPopup(`
          <div style="width:280px">
            <strong>${name}</strong><br/>
            <div id="council-${code}" style="font-size: 0.9em; color: #444;">
              Loading council info…
            </div>
            <hr/>
            <button onclick="viewStats(${code})">View Statistics</button>
            <button onclick="viewNationalities(${code}, '${name}')">View Nationalities</button>
            <button onclick="viewNationalityRace(${code}, '${name}')">Play bar-race</button>
            <button onclick="viewLanguage(${code}, '${name}')">View Language</button>
          </div>
        `);

        // Trigger council info fetch when popup is opened
        layer.on('popupopen', () => viewCouncilInfo(code));
      }
    }).addTo(map); // Add the complete LGA layer to the map
  });

  function viewCouncilInfo(code) {
  fetch(`/api/lga/council/${code}`)
    .then(r => r.json())
    .then(([council]) => {
      const el = document.getElementById(`council-${code}`);
      if (!el) return;

      el.innerHTML = `
        <strong>${council.council_name}</strong><br/>
        <small>${council.council_info}</small><br/><br/>
        <div style="margin-top: 6px;">
          <i class="bi bi-geo-alt-fill" style="color:#d9534f;"></i>
          ${council.address}, ${council.suburb} ${council.postcode}<br/>

          <i class="bi bi-telephone-fill" style="color:#5bc0de;"></i>
          <a href="tel:${council.phone}">${council.phone}</a><br/>

          <i class="bi bi-envelope-fill" style="color:#5cb85c;"></i>
          <a href="mailto:${council.email}">${council.email}</a><br/>

          <i class="bi bi-globe2" style="color:#0275d8;"></i>
          <a href="https://${council.website}" target="_blank">Website</a>
        </div>
      `;
    })
    .catch(err => {
      const el = document.getElementById(`council-${code}`);
      if (el) el.textContent = 'Council info not available.';
      console.error('Council info fetch failed', err);
    });
}




  function viewStats(code) {
  fetch(`/api/lga/statistics-full?code=${code}`)
    .then(r => r.json())
    .then(d => {
      showPanel('LGA Statistics');
      addSource(
        'Data Source: ABS Data Region Methodology (2011–24)',
        'https://www.abs.gov.au/methodologies/data-region-methodology/2011-24'
      );

      const cards = [
        { key:'total_businesses',               label:'Businesses',            unit:'',
          icon:'bi-shop' },
        { key:'total_employed_over_15',         label:'Employed (15+)',        unit:'',
          icon:'bi-briefcase-fill' },
        { key:'born_overseas',                  label:'Born overseas',         unit:'',
          icon:'bi-globe2' },
        { key:'pct_arrived_within_5_years',     label:'Arrived ≤5 yrs',        unit:'%',
          icon:'bi-airplane-engines' },
        { key:'pct_proficient_english',         label:'Proficient English',    unit:'%',
          icon:'bi-chat-dots-fill' },
        { key:'pct_speaks_other_lang_at_home', label:'Other lang @home',  unit:'%',
          icon:'bi-translate' },
        { key:'median_age_years',               label:'Median age',            unit:'yrs',
          icon:'bi-person-vcard' },
        { key:'pct_completed_year_12',          label:'Year-12 completed',     unit:'%',
          icon:'bi-mortarboard' },
        { key:'pct_certificate',                label:'Certificate',           unit:'%',
          icon:'bi-award-fill' },
        { key:'pct_bachelor_degree',            label:'Bachelor degree',       unit:'%',
          icon:'bi-mortarboard-fill' },
        { key:'pct_postgraduate',               label:'Post-graduate',         unit:'%',
          icon:'bi-journal-richtext' },
        { key:'pct_managers',                   label:'Managers',              unit:'%',
          icon:'bi-diagram-3-fill' },
        { key:'pct_professionals',              label:'Professionals',         unit:'%',
          icon:'bi-person-workspace' },
        { key:'pct_labourers',                  label:'Labourers',             unit:'%',
          icon:'bi-hammer' }
      ];

      /* HTML grid */
      const grid = document.createElement('div');
      grid.className = 'kpi-grid';

      grid.innerHTML = cards.map(c => {
        const raw = d[c.key];
        const val = raw == null ? '—'
                  : c.unit === '%'  ? (+raw).toFixed(1) + ' %'   // thin space before %
                  : c.unit === 'yrs'? (+raw).toFixed(1) + ' yrs'
                  : (+raw).toLocaleString();
        return `
          <div class="kpi-card">
            <i class="bi ${c.icon} kpi-icon"></i>
            <div class="kpi-value">${val}</div>
            <div class="kpi-label">${c.label}</div>
          </div>`;
      }).join('');

      plotEl.appendChild(grid);
    });
}


function viewNationalityRace(code, lgaName) {
  // Fetch nationality race data for the given LGA code
  fetch(`/api/lga/nationalities-race/${code}`)
    .then(r => r.json())
    .then(raw => {
      // Get unique years (sorted) from the data
      const years = [...new Set(raw.map(d => d.year))].sort((a, b) => a - b);
      // Create maps for cumulative counts per nationality year by year
      const cumulativeByYear = new Map();
      const running = new Map();
      
      // Build cumulative counts for each year
      years.forEach(yr => {
        raw.filter(d => d.year === yr).forEach(d => {
          running.set(d.nationality, (running.get(d.nationality) || 0) + d.count);
        });
        cumulativeByYear.set(yr, new Map(running));
      });

      // Create frames for animation by interpolating between each pair of years
      const frames = [];
      for (let i = 0; i < years.length - 1; i++) {
        const y0 = years[i],
              y1 = years[i + 1];
        const t0 = cumulativeByYear.get(y0),
              t1 = cumulativeByYear.get(y1);
        const span = y1 - y0;

        // Interpolate counts for each "in-between" year
        for (let off = 0; off < span; off++) {
          const year = y0 + off;
          const interp = [...new Set([...t0.keys(), ...t1.keys()])].map(nat => {
            const c0 = t0.get(nat) || 0;
            const c1 = t1.get(nat) || c0;
            return { nationality: nat, count: c0 + (c1 - c0) * (off / span) };
          });
          // Store only the top 10 nationalities per frame
          frames.push({
            year,
            rows: interp.sort((a, b) => b.count - a.count).slice(0, 10)
          });
        }
      }
      
      // Add the final frame for the last year in the dataset
      const last = years[years.length - 1];
      frames.push({
        year: last,
        rows: [...cumulativeByYear.get(last).entries()]
          .map(([n, c]) => ({ nationality: n, count: c }))
          .sort((a, b) => b.count - a.count)
          .slice(0, 10)
      });

      // Display the panel with a specified title
      showPanel('Arrivals 1951–2021');
      
      // Set up the SVG container for the bar chart race
      const svg = d3.select(plotEl)
        .append('svg')
        .attr('width', 900)
        .attr('height', 550);

      // Define margins and calculate chart dimensions
      const m = { top: 60, right: 90, bottom: 60, left: 200 };
      const w = +svg.attr('width') - m.left - m.right;
      const h = +svg.attr('height') - m.top - m.bottom;

      // Append a group element shifted by the margins
      const g = svg.append('g')
        .attr('transform', `translate(${m.left},${m.top})`);

      // Define scales and formatter
      const x = d3.scaleLinear().range([0, w]);
      const y = d3.scaleBand().range([0, h]).padding(0.1);
      const fmt = d3.format(',d');

      // Compute unique nationalities and assign them colors
      const allNats = [...new Set(raw.map(d => d.nationality))];
      const colour = d3.scaleOrdinal()
        .domain(allNats)
        .range(d3.quantize(d3.interpolateSinebow, allNats.length));

      // Append groups for axes and a text element for the year label
      const yAxisG = g.append('g');
      const xAxisTop = g.append('g');
      const yearLabel = svg.append('text')
        .attr('x', m.left + w)
        .attr('y', m.top + h + 30)
        .attr('text-anchor', 'end')
        .attr('font-size', 22)
        .attr('font-weight', 'bold');

      // Create a group for the chart title and append title text
      const titleG = svg.append('g')
        .attr('class', 'plot-title')
        .attr('transform', `translate(${m.left + w / 2}, 20)`);

      const titleTxt = titleG.append('text')
        .attr('text-anchor', 'middle')
        .attr('font-weight', 'bold')
        .attr('font-size', '22px')
        .text(`Number of Yearly Arrivals in ${lgaName}`);

      // Define icon size and append an icon next to the title for decoration
      const iconSize = 30;
      const txtBox = titleTxt.node().getBBox();
      titleG.append('svg')
        .attr('x', txtBox.width / 2 + 3)
        .attr('y', -iconSize / 2)
        .attr('width', iconSize)
        .attr('height', iconSize)
        .html(`
          <path d="M9.5 1.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0M6.44 3.752A.75.75 0 0 1 7 3.5h1.445c.742 0 1.32.643 1.243 1.38l-.43 4.083a1.8 1.8 0 0 1-.088.395l-.318.906.213.242a.8.8 0 0 1 .114.175l2 4.25a.75.75 0 1 1-1.357.638l-1.956-4.154-1.68-1.921A.75.75 0 0 1 6 8.96l.138-2.613-.435.489-.464 2.786a.75.75 0 1 1-1.48-.246l.5-3a.75.75 0 0 1 .18-.375l2-2.25Z"/>
          <path d="M6.25 11.745v-1.418l1.204 1.375.261.524a.8.8 0 0 1-.12.231l-2.5 3.25a.75.75 0 1 1-1.19-.914zm4.22-4.215-.494-.494.205-1.843.006-.067 1.124 1.124h1.44a.75.75 0 0 1 0 1.5H11a.75.75 0 0 1-.531-.22Z"/>
        `);

      // Function to render a single frame of the animation
      function render(frame) {
        // Define a transition for smooth updates
        const t = svg.transition().duration(250).ease(d3.easeLinear);
        // Update the x-scale domain based on the maximum count in the frame
        x.domain([0, d3.max(frame.rows, d => d.count)]);
        // Update the y-scale domain with the current nationalities
        y.domain(frame.rows.map(d => d.nationality));

        // Bind data to rectangle elements (bars) and update their dimensions
        const bars = g.selectAll('rect').data(frame.rows, d => d.nationality);
        bars.exit().transition(t).attr('width', 0).remove();
        const enter = bars.enter().append('rect')
          .attr('x', 0)
          .attr('y', d => y(d.nationality))
          .attr('height', y.bandwidth())
          .attr('fill', d => colour(d.nationality))
          .attr('width', 0);
        enter.merge(bars).transition(t)
          .attr('y', d => y(d.nationality))
          .attr('width', d => x(d.count));

        // Bind data to text elements (bar labels) and update their values
        const labels = g.selectAll('text.barLbl').data(frame.rows, d => d.nationality);
        labels.exit().remove();
        labels.enter().append('text')
          .attr('class', 'barLbl')
          .attr('text-anchor', 'start')
          .attr('dy', '0.35em')
          .merge(labels)
          .transition(t)
          .attr('x', d => x(d.count) + 6)
          .attr('y', d => y(d.nationality) + y.bandwidth() / 2)
          .tween('text', function (d) {
            const i = d3.interpolateNumber(+this.textContent.replace(/,/g, '') || 0, d.count);
            return t => this.textContent = fmt(i(t));
          });

        // Update the axes with the new scales
        xAxisTop.transition(t).attr('transform', 'translate(0,0)').call(d3.axisTop(x).ticks(4));
        yAxisG.transition(t).call(d3.axisLeft(y));
        // Update the year label with the current frame's year
        yearLabel.text(frame.year);
      }

      // Start rendering the animation from the first frame
      let idx = 0;
      render(frames[idx]);
      const timer = d3.interval(() => {
        idx += 1;
        // Stop the timer when all frames have been rendered
        if (idx >= frames.length) timer.stop();
        else render(frames[idx]);
      }, 250);

      // Append a data source link below the chart
      addSource(
        'Data Source: ABS Census DataPacks',
        'https://www.abs.gov.au/census/find-census-data/datapacks'
      );
    });
}

/* --- bar‑chart race --- */
function viewNationalityRace(code, lgaName) {
  // Fetch nationality race data for the given LGA code
  fetch(`/api/lga/nationalities-race/${code}`)
    .then(r => r.json())
    .then(raw => {
      // Get unique years (sorted) from the data
      const years = [...new Set(raw.map(d => d.year))].sort((a, b) => a - b);
      // Create maps for cumulative counts per nationality year by year
      const cumulativeByYear = new Map();
      const running = new Map();
      
      // Build cumulative counts for each year
      years.forEach(yr => {
        raw.filter(d => d.year === yr).forEach(d => {
          running.set(d.nationality, (running.get(d.nationality) || 0) + d.count);
        });
        cumulativeByYear.set(yr, new Map(running));
      });

      // Create frames for animation by interpolating between each pair of years
      const frames = [];
      for (let i = 0; i < years.length - 1; i++) {
        const y0 = years[i],
              y1 = years[i + 1];
        const t0 = cumulativeByYear.get(y0),
              t1 = cumulativeByYear.get(y1);
        const span = y1 - y0;

        // Interpolate counts for each "in-between" year
        for (let off = 0; off < span; off++) {
          const year = y0 + off;
          const interp = [...new Set([...t0.keys(), ...t1.keys()])].map(nat => {
            const c0 = t0.get(nat) || 0;
            const c1 = t1.get(nat) || c0;
            return { nationality: nat, count: c0 + (c1 - c0) * (off / span) };
          });
          // Store only the top 10 nationalities per frame
          frames.push({
            year,
            rows: interp.sort((a, b) => b.count - a.count).slice(0, 10)
          });
        }
      }
      
      // Add the final frame for the last year in the dataset
      const last = years[years.length - 1];
      frames.push({
        year: last,
        rows: [...cumulativeByYear.get(last).entries()]
          .map(([n, c]) => ({ nationality: n, count: c }))
          .sort((a, b) => b.count - a.count)
          .slice(0, 10)
      });

      // Display the panel with a specified title
      showPanel('Arrivals 1951–2021');
      
      // Set up the SVG container for the bar chart race
      const svg = d3.select(plotEl)
        .append('svg')
        .attr('width', 900)
        .attr('height', 550);

      // Define margins and calculate chart dimensions
      const m = { top: 60, right: 90, bottom: 60, left: 200 };
      const w = +svg.attr('width') - m.left - m.right;
      const h = +svg.attr('height') - m.top - m.bottom;

      // Append a group element shifted by the margins
      const g = svg.append('g')
        .attr('transform', `translate(${m.left},${m.top})`);

      // Define scales and formatter
      const x = d3.scaleLinear().range([0, w]);
      const y = d3.scaleBand().range([0, h]).padding(0.1);
      const fmt = d3.format(',d');

      // Compute unique nationalities and assign them colors
      const allNats = [...new Set(raw.map(d => d.nationality))];
      const colour = d3.scaleOrdinal()
        .domain(allNats)
        .range(d3.quantize(d3.interpolateSinebow, allNats.length));

      // Append groups for axes and a text element for the year label
      const yAxisG = g.append('g');
      const xAxisTop = g.append('g');
      const yearLabel = svg.append('text')
        .attr('x', m.left + w)
        .attr('y', m.top + h + 30)
        .attr('text-anchor', 'end')
        .attr('font-size', 22)
        .attr('font-weight', 'bold');

      // Create a group for the chart title and append title text
      const titleG = svg.append('g')
        .attr('class', 'plot-title')
        .attr('transform', `translate(${m.left + w / 2}, 20)`);

      const titleTxt = titleG.append('text')
        .attr('text-anchor', 'middle')
        .attr('font-weight', 'bold')
        .attr('font-size', '22px')
        .text(`Number of Yearly Arrivals in ${lgaName}`);

      // Define icon size and append an icon next to the title for decoration
      const iconSize = 30;
      const txtBox = titleTxt.node().getBBox();
      titleG.append('svg')
        .attr('x', txtBox.width / 2 + 3)
        .attr('y', -iconSize / 2)
        .attr('width', iconSize)
        .attr('height', iconSize)
        .html(`
          <path d="M9.5 1.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0M6.44 3.752A.75.75 0 0 1 7 3.5h1.445c.742 0 1.32.643 1.243 1.38l-.43 4.083a1.8 1.8 0 0 1-.088.395l-.318.906.213.242a.8.8 0 0 1 .114.175l2 4.25a.75.75 0 1 1-1.357.638l-1.956-4.154-1.68-1.921A.75.75 0 0 1 6 8.96l.138-2.613-.435.489-.464 2.786a.75.75 0 1 1-1.48-.246l.5-3a.75.75 0 0 1 .18-.375l2-2.25Z"/>
          <path d="M6.25 11.745v-1.418l1.204 1.375.261.524a.8.8 0 0 1-.12.231l-2.5 3.25a.75.75 0 1 1-1.19-.914zm4.22-4.215-.494-.494.205-1.843.006-.067 1.124 1.124h1.44a.75.75 0 0 1 0 1.5H11a.75.75 0 0 1-.531-.22Z"/>
        `);

      // Function to render a single frame of the animation
      function render(frame) {
        // Define a transition for smooth updates
        const t = svg.transition().duration(250).ease(d3.easeLinear);
        // Update the x-scale domain based on the maximum count in the frame
        x.domain([0, d3.max(frame.rows, d => d.count)]);
        // Update the y-scale domain with the current nationalities
        y.domain(frame.rows.map(d => d.nationality));

        // Bind data to rectangle elements (bars) and update their dimensions
        const bars = g.selectAll('rect').data(frame.rows, d => d.nationality);
        bars.exit().transition(t).attr('width', 0).remove();
        const enter = bars.enter().append('rect')
          .attr('x', 0)
          .attr('y', d => y(d.nationality))
          .attr('height', y.bandwidth())
          .attr('fill', d => colour(d.nationality))
          .attr('width', 0);
        enter.merge(bars).transition(t)
          .attr('y', d => y(d.nationality))
          .attr('width', d => x(d.count));

        // Bind data to text elements (bar labels) and update their values
        const labels = g.selectAll('text.barLbl').data(frame.rows, d => d.nationality);
        labels.exit().remove();
        labels.enter().append('text')
          .attr('class', 'barLbl')
          .attr('text-anchor', 'start')
          .attr('dy', '0.35em')
          .merge(labels)
          .transition(t)
          .attr('x', d => x(d.count) + 6)
          .attr('y', d => y(d.nationality) + y.bandwidth() / 2)
          .tween('text', function (d) {
            const i = d3.interpolateNumber(+this.textContent.replace(/,/g, '') || 0, d.count);
            return t => this.textContent = fmt(i(t));
          });

        // Update the axes with the new scales
        xAxisTop.transition(t).attr('transform', 'translate(0,0)').call(d3.axisTop(x).ticks(4));
        yAxisG.transition(t).call(d3.axisLeft(y));
        // Update the year label with the current frame's year
        yearLabel.text(frame.year);
      }

      // Start rendering the animation from the first frame
      let idx = 0;
      render(frames[idx]);
      const timer = d3.interval(() => {
        idx += 1;
        // Stop the timer when all frames have been rendered
        if (idx >= frames.length) timer.stop();
        else render(frames[idx]);
      }, 250);

      // Append a data source link below the chart
      addSource(
        'Data Source: ABS Census DataPacks',
        'https://www.abs.gov.au/census/find-census-data/datapacks'
      );
    });
}

// 1) Map each language to its primary ISO country code
const languageToCountry = {
  Afrikaans: 'ZA', Arabic: 'SA', AIndLng: 'IN', Canton: 'HK',
  Mandarin: 'CN', Croatian: 'HR', French: 'FR', German: 'DE',
  Greek: 'GR', Bengali: 'BD', Guj: 'IN', Hindi: 'IN',
  Nepali: 'NP', Punjabi: 'PK', Sinhal: 'LK', Urdu: 'PK',
  Italian: 'IT', Japan: 'JP', Khmer: 'KH', Korean: 'KR',
  Macedon: 'MK', Malayalam: 'IN', Persian: 'IR', Polish: 'PL',
  Portuguese: 'PT', Russian: 'RU', Samoan: 'WS', Serbian: 'RS',
  Filipin: 'PH', Indon: 'ID', Tagalog: 'PH', Spanish: 'ES',
  Tamil: 'IN', Thai: 'TH', Turkish: 'TR', Vietnamese: 'VN'
};

// 2) flag palette colours
const flagColors = {
  CN: ['#DE2910','#FFDE00'],      // stays red/yellow
  DE: ['#000000','#FFCE00'],      // black/gold (drop the red)
  FR: ['#0055A4','#EF4135'],      // blue/red (drop the white)
  IN: ['#138808','#FF9933'],      // green/orange (drop the white)
  IT: ['#008C45','#CD212A'],      // green/red (drop the white)
  JP: ['#FFFFFF','#BC002D'],      // still white/red
  KR: ['#C60C30','#003478'],      // red/blue (drop the white)
  SA: ['#006C35','#FFFFFF'],      // keep green/white since it’s only two
  ZA: ['#006847','#FFB612'],
  HK: ['#DE2910','#FFFFFF'],      // red/white
  HR: ['#0000FF','#FF0000'],      // blue/red (drop the white)
  GR: ['#0D5EAF','#FFFFFF'],      // blue/white
  BD: ['#006A4E','#F42A41'],
  NP: ['#BE1E2D','#003893'],      // red/blue (drop the white)
  PK: ['#01411C','#FFFFFF'],
  LK: ['#800000','#FFB612'],
  PL: ['#DC143C','#FFFFFF'],      // red/white
  PT: ['#FF0000','#006600'],      // red/green (swap order as you like)
  RU: ['#0039A6','#D52B1E'],      // blue/red (drop the white)
  ES: ['#AA151B','#F1BF00'],
  TH: ['#DC241F','#003478'],      // red/blue
  TR: ['#E30A17','#FFFFFF'],
  VN: ['#DA251D','#FFFF00'],
  PH: ['#CE1126','#0038A8'],      // red/blue (drop yellow & white)
  ID: ['#FF0000','#FFFFFF'],
  RS: ['#0000C8','#FF0000'],      // blue/red
  WS: ['#D21034','#00205B'],
  MK: ['#FF0000','#FFDA44'],
  KH: ['#ED1B24','#032EA1']
};

// 0) Native‐name lookup for all your DB languages
const nativeNames = {
  Afrikaans: 'Afrikaans',
  Arabic:    'العربية',
  AIndLng:   '',               // no single native name
  Canton:    '廣東話',
  Mandarin:  '中文',
  Croatian:  'hrvatski',
  French:    'Français',
  German:    'Deutsch',
  Greek:     'Ελληνικά',
  Bengali:   'বাংলা',
  Guj:       'ગુજરાતી',
  Hindi:     'हिन्दी',
  Nepali:    'नेपाली',
  Punjabi:   'ਪੰਜਾਬੀ',
  Sinhal:    'සිංහල',
  Urdu:      'اردو',
  Italian:   'Italiano',
  Japan:     '日本語',
  Khmer:     'ភាសាខ្មែរ',
  Korean:    '한국어',
  Macedon:   'македонски',
  Malayalam: 'മലയാളം',
  Persian:   'فارسی',
  Polish:    'Polski',
  Portuguese:'Português',
  Russian:   'Русский',
  Samoan:    'Gagana Samoa',
  Serbian:   'српски',
  Filipin:   'Filipino',
  Indon:     'Bahasa Indonesia',
  Tagalog:   'Tagalog',
  Spanish:   'Español',
  Tamil:     'தமிழ்',
  Thai:      'ไทย',
  Turkish:   'Türkçe',
  Vietnamese:'Tiếng Việt'
};


/* --- language proficiency pie --- */
function viewLanguage(lgaCode, lgaName) {
  fetch(`/api/lga/language-proficiency/${lgaCode}`)
    .then(r => r.json())
    .then(all => {
      showPanel(`Language Proficiency – ${lgaName}`);
      plotEl.innerHTML = `
        <label for="langSel"><strong>Select a language:</strong></label>
        <select id="langSel" style="margin-bottom:12px;"></select>
        <div id="langPie"></div>
      `;

      const sel   = document.getElementById('langSel');
      
      const langs = Array.from(new Set(all.map(d => d.language))).sort();
      sel.innerHTML = langs.map(l => {
        const nat = nativeNames[l] || '';
        return `<option value="${l}">${l}${nat ? ' ' + nat : ''}</option>`;
      }).join('');


      sel.onchange = () => drawPie(sel.value);
      drawPie(langs[0]);

      function drawPie(language) {
        const filtered = all.filter(d => d.language === language);
        const container = d3.select('#langPie').html('');

        const nat = nativeNames[language] || '';
        // build a label like "Mandarin 中文" or just "AIndLng" if none
        const langLabel = nat ? `${language} ${nat}` : language;

        // Title
        container.append('div')
          .style('text-align','center')
          .style('margin-bottom','8px')
          .style('font-weight','bold')
          .text(`English Proficiency Level for ${langLabel}`);

        if (!filtered.some(d => d.count > 0)) {
          return container.append('p')
            .style('text-align','center')
            .text(`No data for ${language} in ${lgaName}.`);
        }

        // prepare data
        const positive = filtered.filter(d => d.count > 0);
        const total    = d3.sum(positive, d => d.count);
        const data     = positive.map(d => ({
          name:  d.level,
          value: d.count/total*100
        }));

        // pick slice colors
        const cc     = languageToCountry[language];
        const slices = (cc && flagColors[cc]) ? flagColors[cc] : d3.schemeCategory10;
        const color  = d3.scaleOrdinal()
                           .domain(data.map(d=>d.name))
                           .range(slices.slice(0,data.length));

        // line color = white if flag has 3+ colors
        const lineColor = (cc && flagColors[cc] && flagColors[cc].length>2)
                          ? 'white'
                          : 'black';

        // dimensions
        const width   = 640,
              height  = 420,
              radius  = Math.min(width,height)/2 - 20;

        const pieGen = d3.pie().sort(null).value(d=>d.value);
        const arcGen = d3.arc().innerRadius(0).outerRadius(radius);
        const arcs   = pieGen(data);

        // draw SVG
        const svg = container.append('svg')
          .attr('width',width)
          .attr('height',height)
          .attr('overflow','visible')
          .style('display','block')
          .style('margin','0 auto')
          .append('g')
            .attr('transform',`translate(${width/2},${height/2})`);

        // slices
        const paths = svg.append('g').attr('stroke','white')
          .selectAll('path').data(arcs).join('path')
            .attr('fill', d=>color(d.data.name))
            .each(function(d){ this._current = {startAngle:d.startAngle,endAngle:d.startAngle}; });

        paths.transition().duration(800)
             .attrTween('d', function(d){
               const i = d3.interpolate(this._current,d);
               this._current = i(1);
               return t=>arcGen(i(t));
             });

        // tooltips
        paths.append('title')
             .text(d=>`${d.data.name}: ${d.data.value.toFixed(1)}%`);

        // labels + lines
        const labelOffset = radius+20;
        const outerArc = d3.arc().innerRadius(radius*1.05).outerRadius(radius*1.05);

        // lines
        svg.append('g').attr('class','lines')
          .selectAll('polyline')
          .data(arcs).join('polyline')
            .attr('points', d=>{
              const c   = arcGen.centroid(d);
              const o1  = outerArc.centroid(d);
              const mid = (d.startAngle + d.endAngle)/2;
              const o2  = [o1[0],o1[1]];
              o2[0] = labelOffset * (mid < Math.PI ? 1 : -1);
              return [c,o1,o2];
            })
            .attr('stroke', lineColor)
            .attr('fill','none')
            .attr('opacity',0.5);

        // text
        svg.append('g').attr('class','labels')
          .selectAll('text')
          .data(arcs).join('text')
            .attr('font-size','10px')
            .attr('transform', d=>{
              const mid = (d.startAngle + d.endAngle)/2;
              const o   = outerArc.centroid(d);
              o[0] = labelOffset * (mid < Math.PI ? 1 : -1);
              return `translate(${o})`;
            })
            .attr('text-anchor', d=>{
              const mid = (d.startAngle + d.endAngle)/2;
              return mid < Math.PI ? 'start' : 'end';
            })
          .call(t => t.append('tspan')
              .attr('font-weight','bold')
              .text(d=>d.data.name))
              .call(t => t
              .append('tspan')
                .attr('x',0).attr('dy','1em').attr('fill-opacity',0.6)
                .text(d=>d.data.value.toFixed(1)+'%'));

        addSource(
          'Data Source: ABS Census DataPacks',
          'https://www.abs.gov.au/census/find-census-data/datapacks'
        );
      }
    });
}


</script>
</body>
</html>

